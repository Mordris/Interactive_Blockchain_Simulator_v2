# transaction.py

from utils.crypto_utils import get_data_to_sign # To prepare data for signing

class Transaction:
    """
    Represents a single transaction in the blockchain.
    Each transaction has a sender (public key), a recipient (public key),
    an amount, and a signature from the sender.
    """
    def __init__(self, sender_public_key: str, recipient_public_key: str, amount: float, signature: str | None = None):
        """
        Initializes a new transaction.

        Args:
            sender_public_key (str): The public key (PEM format) of the sender.
                                     Can be "network", "welcome_faucet" for system transactions.
            recipient_public_key (str): The public key (PEM format) of the recipient.
            amount (float): The amount being transferred. Must be positive.
            signature (str | None, optional): The transaction signature (hex string) generated by the sender.
                                              None for system transactions or if signature is to be added later.
        """
        if not isinstance(sender_public_key, str) or not sender_public_key:
            raise ValueError("Sender public key must be a non-empty string.")
        if not isinstance(recipient_public_key, str) or not recipient_public_key:
            raise ValueError("Recipient public key must be a non-empty string.")
        if not isinstance(amount, (int, float)) or amount <= 0:
            raise ValueError("Amount must be a positive number.")
        if signature is not None and (not isinstance(signature, str) or not signature): # Allow empty string for signature if needed? No, should be valid hex or None.
            raise ValueError("Signature, if provided, must be a non-empty hex string.")

        self.sender_public_key: str = sender_public_key
        self.recipient_public_key: str = recipient_public_key
        self.amount: float = float(amount)
        self.signature: str | None = signature # Hex string of the signature

    def get_data_for_signing(self) -> str:
        """
        Generates the canonical string representation of the transaction data
        that needs to be signed by the sender. Excludes the signature itself.
        """
        return get_data_to_sign(self.sender_public_key, self.recipient_public_key, self.amount)

    def to_dict(self) -> dict:
        """
        Returns a dictionary representation of the transaction.
        Useful for serialization and hashing within a block.
        """
        return {
            'sender_public_key': self.sender_public_key,
            'recipient_public_key': self.recipient_public_key,
            'amount': self.amount,
            'signature': self.signature
        }

    @classmethod
    def from_dict(cls, tx_data: dict) -> 'Transaction':
        """
        Creates a Transaction object from a dictionary.
        """
        if not all(k in tx_data for k in ['sender_public_key', 'recipient_public_key', 'amount']):
            raise ValueError("Transaction data dictionary is missing required keys.")
        return cls(
            sender_public_key=tx_data['sender_public_key'],
            recipient_public_key=tx_data['recipient_public_key'],
            amount=float(tx_data['amount']), # Ensure amount is float
            signature=tx_data.get('signature') # Signature might be None
        )

    def __repr__(self) -> str:
        # Determine short sender display
        if self.sender_public_key in ["network", "welcome_faucet"]:
            short_sender = self.sender_public_key.upper()
        elif len(self.sender_public_key) > 30: # Arbitrary length for shortening PEM
            short_sender = self.sender_public_key[:15] + "..." + self.sender_public_key[-15:]
        else:
            short_sender = self.sender_public_key

        # Determine short recipient display
        if len(self.recipient_public_key) > 30:
            short_recipient = self.recipient_public_key[:15] + "..." + self.recipient_public_key[-15:]
        else:
            short_recipient = self.recipient_public_key
            
        sig_status = "N/A" if self.sender_public_key in ["network", "welcome_faucet"] else ("Signed" if self.signature else "Unsigned")
        
        return (f"Transaction(From: {short_sender}, To: {short_recipient}, "
                f"Amount: {self.amount:.4f}, Signature: {sig_status})")

    def __eq__(self, other) -> bool:
        if not isinstance(other, Transaction):
            return NotImplemented
        return (self.sender_public_key == other.sender_public_key and
                self.recipient_public_key == other.recipient_public_key and
                self.amount == other.amount and
                self.signature == other.signature)

if __name__ == '__main__':
    from utils.crypto_utils import generate_key_pair, sign_data, verify_signature

    print("--- Testing Transaction Class with Signatures ---")
    
    alice_priv, alice_pub = generate_key_pair()
    bob_priv, bob_pub = generate_key_pair()

    amount_to_send = 50.12345678
    data_to_sign_alice = get_data_to_sign(alice_pub, bob_pub, amount_to_send) # Uses .8f precision
    alice_signature = sign_data(alice_priv, data_to_sign_alice)

    tx1 = Transaction(
        sender_public_key=alice_pub,
        recipient_public_key=bob_pub,
        amount=amount_to_send, # Store full precision
        signature=alice_signature
    )
    print(f"Transaction 1: {tx1}") # __repr__ uses .4f for display
    print(f"Dictionary: {tx1.to_dict()}") # to_dict stores full float precision

    is_tx1_valid_sig = verify_signature(
        tx1.sender_public_key,
        tx1.get_data_for_signing(), # This will use .8f precision
        tx1.signature
    )
    print(f"Is Transaction 1 signature valid? {is_tx1_valid_sig}")
    assert is_tx1_valid_sig

    reward_tx = Transaction(
        sender_public_key="network",
        recipient_public_key=alice_pub,
        amount=100.0
    )
    print(f"Reward Transaction: {reward_tx}")
    assert reward_tx.signature is None

    tx1_dict = tx1.to_dict()
    recreated_tx1 = Transaction.from_dict(tx1_dict)
    assert tx1 == recreated_tx1, f"Equality failed: {tx1} != {recreated_tx1}"
    print("Transaction.from_dict and __eq__ test PASSED.")

    print("\nAll Transaction class self-tests passed!")